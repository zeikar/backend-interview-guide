# 쿠버네티스(Kubernetes)

## 목차

- [쿠버네티스란?](#쿠버네티스란)
- [쿠버네티스의 주요 구성 요소](#쿠버네티스의-주요-구성-요소)
- [쿠버네티스의 장점](#쿠버네티스의-장점)
- [쿠버네티스의 단점](#쿠버네티스의-단점)
- [쿠버네티스 사용 시 주의할 점](#쿠버네티스-사용-시-주의할-점)
- [쿠버네티스 배포](#쿠버네티스-배포)
  - [무중단 배포란?](#무중단-배포란)
  - [배포 전략](#배포-전략)
  - [무중단 배포를 위한 파드 세팅](#무중단-배포를-위한-파드-세팅)
  - [무중단 배포 시 주의 사항](#무중단-배포-시-주의-사항)

---

## 쿠버네티스란?

**쿠버네티스(Kubernetes, K8s)** 는 **컨테이너화된 애플리케이션을 자동으로 배포, 확장, 관리**하기 위한 **오픈 소스 컨테이너 오케스트레이션 플랫폼**입니다. 컨테이너를 개별적으로 관리하는 대신, 쿠버네티스를 사용하면 클러스터(Cluster) 내에서 여러 컨테이너를 체계적으로 배포하고, 자원을 효율적으로 활용하며, 애플리케이션의 상태를 지속적으로 모니터링할 수 있습니다.

쿠버네티스는 Google에서 개발되었으며, 이후 **Cloud Native Computing Foundation(CNCF)** 에서 관리되고 있습니다. 쿠버네티스는 특히 **클라우드 네이티브 애플리케이션**과 **마이크로서비스 아키텍처**를 지원하는 핵심 기술로 자리 잡고 있습니다.

**주요 기능:**

1. **컨테이너 배포 관리:** 애플리케이션을 다양한 환경(온프레미스, 클라우드 등)에 자동으로 배포할 수 있습니다.
2. **자동화된 확장(Auto-scaling):** 워크로드에 따라 컨테이너 수를 자동으로 늘리거나 줄이는 기능을 제공합니다.
3. **셀프 힐링(Self-healing):** 장애가 발생한 컨테이너를 자동으로 재시작하거나 복구하며, 원하는 상태를 유지합니다.
4. **로드 밸런싱 및 서비스 디스커버리:** 네트워크 트래픽을 분산하고 컨테이너 간의 통신을 쉽게 설정할 수 있습니다.

---

## 쿠버네티스의 주요 구성 요소

쿠버네티스는 **클러스터(Cluster)** 구조를 기반으로 동작하며, 여러 구성 요소가 서로 협력하여 컨테이너를 효율적으로 관리합니다.

### 1. **클러스터 (Cluster)**

쿠버네티스 클러스터는 **컨트롤 플레인(Control Plane)** 과 **노드(Node)** 로 구성됩니다. 클러스터는 컨테이너화된 애플리케이션과 그 리소스를 관리하는 기본 단위입니다.

- **컨트롤 플레인(Control Plane):** 클러스터의 중앙 관리 영역으로, 클러스터의 상태를 모니터링하고 제어합니다.
- **노드(Node):** 애플리케이션의 컨테이너를 실제로 실행하는 워커 머신(물리적 또는 가상 서버).

---

### 2. **컨트롤 플레인 구성 요소**

#### (1) **API 서버 (API Server)**

- **역할:** 쿠버네티스 클러스터의 모든 요청을 처리하는 중심 컴포넌트로, 클러스터의 상태를 제어하는 데 사용됩니다.
- **기능:** RESTful API를 통해 외부와의 상호작용을 제공합니다. 개발자나 관리자가 CLI 또는 대시보드를 통해 클러스터를 제어할 때 API 서버가 이를 처리합니다.

#### (2) **컨트롤러 매니저 (Controller Manager)**

- **역할:** 클러스터의 상태를 지속적으로 모니터링하고, 클러스터가 원하는 상태를 유지하도록 조치를 취합니다.
- **예시:** 장애가 발생한 파드(Pod)를 자동으로 복구하거나, 워크로드 확장을 처리합니다.

#### (3) **스케줄러 (Scheduler)**

- **역할:** 새롭게 생성된 파드(Pod)를 실행할 **노드**를 선택합니다.
- **기능:** 클러스터 내의 자원(CPU, 메모리 등)을 고려하여 최적의 노드를 선택합니다.

#### (4) **ETCD**

- **역할:** 쿠버네티스 클러스터의 모든 상태 정보를 저장하는 분산 키-값 저장소.
- **특징:** 클러스터의 상태와 구성 정보를 저장하며, 고가용성을 보장합니다.

---

### 3. **노드(Node) 구성 요소**

#### (1) **Kubelet**

- **역할:** 컨트롤 플레인과 노드 간의 통신을 담당하는 에이전트.
- **기능:** 컨테이너의 상태를 모니터링하고, API 서버로부터 받은 명령에 따라 컨테이너를 시작하거나 중지합니다.

#### (2) **Kube-proxy**

- **역할:** 네트워크 트래픽을 관리하며, 파드 간 통신과 외부 클라이언트와의 통신을 지원합니다.
- **기능:** 로드 밸런싱과 네트워크 정책을 구현합니다.

#### (3) **컨테이너 런타임(Container Runtime)**

- **역할:** 실제로 컨테이너를 실행하는 소프트웨어.
- **예시:** Docker, containerd, CRI-O 등이 있습니다.

---

### 4. **기본 객체 (Kubernetes Objects)**

#### (1) **파드(Pod)**

- **설명:** 쿠버네티스에서 가장 작은 배포 단위로, 하나 이상의 컨테이너를 포함합니다.
- **특징:** 동일한 네트워크 주소와 스토리지를 공유하며, 컨테이너 간 통신이 가능합니다.

#### (2) **서비스(Service)**

- **설명:** 파드의 네트워크 접근을 관리하며, 외부에서 파드에 접근할 수 있는 엔드포인트를 제공합니다.
- **특징:** 동적인 파드 IP 주소를 추적하지 않고, 항상 고정된 접근 방법을 제공합니다.

#### (3) **디플로이먼트(Deployment)**

- **설명:** 애플리케이션의 배포, 업데이트, 복구를 관리하는 객체입니다.
- **기능:** 롤링 업데이트, 롤백 등을 통해 애플리케이션 배포를 쉽게 관리할 수 있습니다.

#### (4) **컨피그맵(ConfigMap) & 시크릿(Secret)**

- **설명:** 애플리케이션의 설정 정보를 관리하는 객체입니다.
- **특징:** ConfigMap은 일반 설정 정보를, Secret은 암호화된 민감 정보를 저장합니다.

---

## 쿠버네티스의 장점

쿠버네티스는 컨테이너화된 애플리케이션을 효율적으로 관리하고, 대규모 시스템에서도 높은 확장성과 가용성을 제공합니다.

### 1. **자동화된 운영**

- **자동 확장:** 애플리케이션의 트래픽이나 부하에 따라 컨테이너를 자동으로 확장 또는 축소할 수 있습니다.
- **셀프 힐링(Self-healing):** 장애가 발생한 파드를 자동으로 재시작하거나 복구하여 애플리케이션의 안정성을 유지합니다.

### 2. **이식성**

- 쿠버네티스는 **클라우드 독립성**을 제공하여, 온프레미스 데이터센터, 퍼블릭 클라우드, 하이브리드 클라우드 환경에서 동일하게 사용할 수 있습니다.

### 3. **로드 밸런싱**

- 컨테이너 간의 네트워크 트래픽을 효율적으로 분산하며, 외부 클라이언트와 내부 파드 간의 통신을 간소화합니다.

### 4. **확장성**

- 쿠버네티스는 수천 대의 노드와 수백만 개의 컨테이너를 관리할 수 있는 **확장성**을 제공합니다.
- **자동 스케일링** 기능을 통해 필요에 따라 애플리케이션 리소스를 자동으로 조정합니다.

### 5. **무중단 배포**

- **롤링 업데이트**를 통해 애플리케이션을 점진적으로 업데이트하여 다운타임을 최소화할 수 있습니다.
- 문제가 발생하면 **롤백** 기능으로 이전 상태로 빠르게 복구할 수 있습니다.

---

## 쿠버네티스의 단점

쿠버네티스는 강력한 기능을 제공하지만, 구현 및 운영에서 몇 가지 단점이 존재합니다.

### 1. **복잡성**

- 쿠버네티스는 기능이 매우 강력하지만, 초기 설정과 구성이 복잡합니다.
- 네트워크, 보안, 리소스 관리 등 다양한 요소를 고려해야 하며, 이를 제대로 설정하지 않으면 문제가 발생할 수 있습니다.

### 2. **학습 곡선**

- 쿠버네티스를 이해하고 활용하려면 높은 수준의 기술적 이해가 필요하며, 이를 배우는 데 많은 시간이 소요될 수 있습니다.
- YAML 파일을 사용한 선언적 구성과 다양한 CLI 명령어는 초보자에게 어렵게 느껴질 수 있습니다.

### 3. **운영 오버헤드**

- 쿠버네티스 클러스터를 운영하려면 **추가적인 리소스**와 관리가 필요합니다. 특히 대규모 클러스터에서는 네트워크, 로깅, 모니터링 등의 복잡한 작업이 요구됩니다.
- 이를 해결하기 위해 클라우드 서비스 제공자의 관리형 쿠버네티스(AWS EKS, GCP GKE, Azure AKS)를 사용하는 경우도 있지만, 추가 비용이 발생합니다.

### 4. **리소스 소비**

- 쿠버네티스 자체가 노드와 클러스터 리소스를 소비하기 때문에, 소규모 애플리케이션에서는 과도한 인프라 자원이 필요할 수 있습니다.

---

## 쿠버네티스 사용 시 주의할 점

쿠버네티스를 효과적으로 사용하려면, 몇 가지 운영 및 관리 측면에서 주의가 필요합니다. 아래는 주요 고려 사항입니다:

### 1. **리소스 요청 및 제한 설정**

- 모든 파드(Pod)에 대해 CPU 및 메모리 **리소스 요청(request)**과 **제한(limit)**을 설정해야 클러스터 자원 남용을 방지할 수 있습니다.
- 리소스 설정이 없을 경우, 특정 파드가 클러스터의 자원을 과도하게 사용하여 다른 서비스에 영향을 줄 수 있습니다.

  ```yaml
  resources:
    requests:
      memory: "128Mi"
      cpu: "250m"
    limits:
      memory: "256Mi"
      cpu: "500m"
  ```

### 2. **보안 설정**

- 네임스페이스(Namespace) 기반 격리를 통해 서비스 간 충돌 및 자원 경쟁을 방지.
- **RBAC(Role-Based Access Control)**을 설정하여 클러스터에 대한 접근 권한을 엄격히 제어.
- 모든 통신에 대해 TLS를 활성화하고, **시크릿(Secret)**을 사용하여 민감한 데이터를 안전하게 저장합니다.

---

## 쿠버네티스 배포

### 무중단 배포란?

**무중단 배포(Zero Downtime Deployment)**는 애플리케이션 배포 시 서비스의 가용성을 유지하면서 업데이트를 수행하는 방식을 의미합니다. 사용자는 배포 중에도 애플리케이션을 계속 사용할 수 있으며, 다운타임이나 서비스 중단 없이 새로운 버전으로 전환됩니다.

무중단 배포는 다음과 같은 상황에서 필수적입니다:

- 대규모 트래픽이 있는 서비스에서 서비스 중단이 불가한 경우.
- 빠른 롤백 및 문제 해결이 필요한 경우.
- 사용자 경험을 우선시하는 애플리케이션 환경.

---

### 배포 전략

#### 롤링 업데이트 (Rolling Update)

기존 인스턴스를 하나씩 교체하여 점진적으로 새로운 버전으로 대체하는 방식입니다.

```yaml
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1
```

- **`maxUnavailable`**: 배포 중 사용할 수 없는 최대 파드 수.
- **`maxSurge`**: 배포 중 추가로 생성 가능한 최대 파드 수.

---

#### 블루-그린 배포 (Blue-Green Deployment)

새로운 버전(Green)을 준비한 뒤, 기존 버전(Blue)에서 새로운 버전으로 트래픽을 전환합니다.

1. 기존 서비스(Blue)와 새로운 서비스(Green)를 병렬로 실행.
2. 트래픽을 새로운 버전으로 전환.
3. 문제가 없으면 Blue를 삭제하거나 대기 상태로 유지.

장점:

- 즉각적인 롤백 가능.
- 업데이트 안전성이 높음.

---

#### 카나리 배포 (Canary Deployment)

새 버전을 전체 트래픽의 일부에만 노출하고, 점진적으로 확장하여 전환하는 방식입니다.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: canary-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
        version: canary
```

- **소규모 테스트** 후, 점차적인 확장을 통해 안정성 검증.

---

#### A/B 테스트

사용자를 그룹으로 나누어 새 버전(A)과 기존 버전(B)을 동시에 제공하는 방식입니다. 성능과 사용자 피드백을 기반으로 새로운 버전의 확장 여부를 결정합니다.

---

### 무중단 배포를 위한 파드 세팅

#### Liveness와 Readiness Probe

- **Liveness Probe**: 파드가 정상적으로 작동 중인지 확인.
- **Readiness Probe**: 파드가 트래픽을 받을 준비가 되었는지 확인.

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 10
```

---

#### PreStop Hook

파드 종료 전에 작업을 수행하여 연결을 안전하게 종료하거나 요청 처리를 마무리.

```yaml
lifecycle:
  preStop:
    exec:
      command: ["sh", "-c", "sleep 5"]
```

---

#### Graceful Shutdown

파드 종료 시, 애플리케이션이 요청을 안전하게 처리할 시간을 확보.

```yaml
spec:
  terminationGracePeriodSeconds: 60
```

---

#### Auto-scaling

트래픽 증가에 따라 파드를 자동으로 확장하여 무중단 배포를 지원.

```yaml
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: example-deployment
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
```

---

#### Pod Anti-Affinity

여러 파드를 동일한 노드에 배치하지 않도록 설정하여 장애 영향을 분산.

```yaml
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app
              operator: In
              values:
                - example
        topologyKey: "kubernetes.io/hostname"
```

---

### 무중단 배포 시 주의 사항

1. **헬스 체크 설정**:

   - Liveness와 Readiness Probe를 정확히 설정하여 비정상적인 파드에 트래픽이 전달되지 않도록 방지.

2. **배포 속도 제어**:

   - 롤링 업데이트나 카나리 배포에서 배포 속도를 조정하여 트래픽 과부하 방지.

3. **로깅 및 모니터링**:

   - Prometheus, Grafana와 같은 도구를 사용하여 배포 중 발생하는 문제를 실시간으로 추적.

4. **테스트 환경 구축**:

   - 블루-그린 또는 카나리 배포 전, 새로운 버전을 충분히 테스트하여 안정성을 검증.

5. **네트워크 안정성 유지**:
   - 로드 밸런서와 네트워크 설정을 통해 서비스 간 통신을 안정적으로 유지.

---

## 결론

쿠버네티스는 현대 IT 환경에서 필수적인 **컨테이너 오케스트레이션 플랫폼**으로, 대규모 애플리케이션의 배포, 확장, 관리를 간소화합니다. 특히 **클라우드 네이티브 애플리케이션**과 **마이크로서비스 아키텍처**를 지원하는 핵심 기술로, 기업의 IT 인프라 운영 효율성을 극대화할 수 있습니다.

그러나 초기 학습 비용과 운영 복잡성을 고려해야 하며, 적절한 클러스터 설계와 관리 전략이 필요합니다. 쿠버네티스를 제대로 활용하면, 애플리케이션의 확장성과 안정성을 극대화할 수 있는 강력한 도구가 될 것입니다.
