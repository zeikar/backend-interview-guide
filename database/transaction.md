# 트랜잭션과 ACID 특성

## 설명

트랜잭션(Transaction)은 데이터베이스에서 수행되는 하나의 작업 단위를 의미하며, 이 작업 단위는 완전히 성공하거나, 실패하여 아무것도 실행되지 않은 상태로 되돌아가야 합니다. 트랜잭션의 ACID 특성은 다음과 같이 정의됩니다:

- **Atomicity (원자성):** 트랜잭션 내의 모든 작업이 완벽하게 수행되거나, 하나도 수행되지 않은 상태로 완료됩니다. 즉, 트랜잭션이 성공하면 모든 작업이 커밋되고, 실패하면 롤백되어 이전 상태로 돌아갑니다.
- **Consistency (일관성):** 트랜잭션이 성공적으로 완료된 후에는 데이터베이스가 항상 일관된 상태를 유지해야 합니다. 트랜잭션이 시작되기 전과 후에 데이터의 무결성이 유지됩니다.
- **Isolation (고립성):** 각 트랜잭션은 다른 트랜잭션으로부터 독립적으로 수행됩니다. 동시에 실행되는 트랜잭션들이 서로의 중간 상태에 영향을 주지 않도록 고립되어야 합니다.
- **Durability (지속성):** 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 데이터베이스에 저장되어야 하며, 시스템 장애가 발생해도 손실되지 않습니다.

# 트랜잭션 격리 수준(Isolation Level)

## 설명

트랜잭션 격리 수준은 동시에 실행되는 트랜잭션 간의 상호작용을 제어하는 방법을 의미합니다. 데이터베이스에서는 네 가지 주요 격리 수준이 있으며, 각 수준은 트랜잭션이 다른 트랜잭션에 미치는 영향을 다르게 제어합니다:

- **Read Uncommitted:** 트랜잭션이 커밋되지 않은 데이터도 읽을 수 있습니다. 데이터의 일관성을 보장하지 않으므로 "Dirty Read"가 발생할 수 있습니다.
- **Read Committed:** 트랜잭션이 커밋된 데이터만 읽을 수 있습니다. Dirty Read는 방지되지만, "Non-Repeatable Read"가 발생할 수 있습니다.
- **Repeatable Read:** 트랜잭션 동안 동일한 데이터를 여러 번 읽어도 동일한 결과가 보장됩니다. 그러나 "Phantom Read"는 발생할 수 있습니다.
- **Serializable:** 가장 높은 수준의 격리 수준으로, 모든 트랜잭션이 직렬화되어 순차적으로 실행된 것처럼 보입니다. Phantom Read도 방지되지만, 성능 저하가 발생할 수 있습니다.

## Dirty Read, Non-Repeatable Read, Phantom Read

- **Dirty Read:** 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 상황입니다. 만약 읽은 데이터가 나중에 롤백되면 잘못된 데이터를 참조하게 됩니다. 이는 Read Uncommitted 격리 수준에서 발생할 수 있습니다.
- **Non-Repeatable Read:** 같은 트랜잭션 내에서 동일한 쿼리를 두 번 실행할 때, 중간에 다른 트랜잭션이 데이터를 수정하여 첫 번째 쿼리와 다른 결과를 반환하는 상황입니다. 이는 Read Committed 격리 수준에서 발생할 수 있습니다.
- **Phantom Read:** 트랜잭션 내에서 동일한 쿼리를 실행할 때, 중간에 다른 트랜잭션이 새로운 데이터를 삽입하여 결과 집합에 추가되는 상황입니다. 이는 Repeatable Read 격리 수준에서도 발생할 수 있으며, Serializable 격리 수준에서만 방지됩니다.

# 분산 트랜잭션(Distributed Transaction)

## 설명

분산 트랜잭션(Distributed Transaction)은 두 개 이상의 독립적인 데이터베이스 시스템 또는 서비스에 걸쳐 수행되는 트랜잭션을 의미합니다. 단일 데이터베이스 내에서의 트랜잭션과 달리, 분산 트랜잭션은 여러 시스템 간의 동기화를 필요로 하므로 모든 참여 시스템에서 트랜잭션의 원자성, 일관성, 고립성, 지속성(ACID 특성)을 보장해야 합니다. 이러한 이유로 분산 트랜잭션은 관리와 구현이 매우 복잡하며, 성능 저하를 유발할 수 있습니다.

## 분산 트랜잭션의 주요 과제

1. **네트워크 장애:** 분산 시스템에서는 네트워크 지연, 패킷 손실, 네트워크 분할 등의 문제로 인해 트랜잭션의 일관성을 유지하는 것이 어려울 수 있습니다.

2. **참여자 간 동기화:** 분산 트랜잭션은 여러 시스템이 참여하므로, 각 시스템이 동일한 트랜잭션 상태를 유지하도록 동기화하는 것이 필수적입니다. 이는 다양한 시스템 간의 시간차, 장애 상황, 리소스 가용성 등을 고려해야 하므로 복잡성이 증가합니다.

3. **트랜잭션 롤백:** 하나의 시스템에서 트랜잭션이 실패할 경우, 트랜잭션에 참여한 모든 시스템에서 롤백을 수행해야 합니다. 이를 위해서는 각 시스템이 이전 상태를 정확히 복구할 수 있어야 하며, 실패 관리가 매우 중요합니다.

## 분산 트랜잭션 관리 기법

### 2-Phase Commit (2PC)

2-Phase Commit은 분산 트랜잭션을 관리하는 대표적인 기법으로, 트랜잭션의 모든 참여자가 트랜잭션을 커밋할 준비가 되었는지 확인한 후에 트랜잭션을 커밋하는 과정을 두 단계로 나누어 처리합니다.

1. **1단계 (Prepare):** 트랜잭션 관리자는 트랜잭션에 참여한 모든 시스템(노드)에게 트랜잭션 준비(Prepare) 요청을 보냅니다. 각 노드는 자신이 트랜잭션을 커밋할 준비가 되었는지 확인한 후, 준비 완료 여부를 응답합니다. 이 과정에서 모든 참여자가 준비가 되었음을 확인받으면 트랜잭션은 준비 상태로 진입합니다.

2. **2단계 (Commit):** 모든 참여자가 준비 완료 응답을 보내면, 트랜잭션 관리자는 각 시스템에 커밋을 지시합니다. 모든 시스템이 커밋을 성공적으로 완료하면, 트랜잭션은 최종적으로 커밋됩니다. 그러나 만약 하나라도 실패한다면, 트랜잭션은 롤백되어 모든 시스템이 이전 상태로 복구됩니다.

**장점:**

- 트랜잭션의 원자성을 강력하게 보장합니다.
- 모든 참여자가 동의해야만 커밋되므로, 데이터 일관성을 확실히 유지할 수 있습니다.

**단점:**

- 네트워크 지연이나 시스템 장애가 발생할 경우, 트랜잭션이 교착 상태에 빠지거나 롤백되는 경우가 빈번할 수 있습니다.
- 전체 시스템의 성능 저하를 유발할 수 있으며, 트랜잭션 처리 시간이 길어질 수 있습니다.

### 3-Phase Commit (3PC)

3-Phase Commit은 2PC의 단점을 보완하기 위해 개발된 기법으로, 중간에 타임아웃 메커니즘을 도입하여 트랜잭션이 교착 상태에 빠지는 것을 방지합니다. 3단계로 트랜잭션을 처리하며, 단계별로 트랜잭션의 상태를 보다 명확하게 관리합니다.

**단점:**

- 2PC에 비해 구현이 복잡하며, 네트워크 오버헤드가 증가합니다.
- 트랜잭션의 처리 과정이 길어질 수 있습니다.

### Saga 패턴

Saga 패턴은 분산 트랜잭션에서 자주 사용되는 또 다른 해결책입니다. 트랜잭션을 여러 개의 작은 단계로 나누고, 각 단계가 성공하면 다음 단계로 넘어가며, 실패 시 이전 단계로 롤백하는 구조입니다. 각 단계는 독립적인 트랜잭션으로 처리되며, 모든 단계가 성공적으로 완료되면 전체 작업이 성공한 것으로 간주합니다.

- **단계적 트랜잭션:** 각 단계는 독립적인 로컬 트랜잭션으로 처리됩니다. 모든 단계가 성공하면 전체 Saga가 성공으로 간주됩니다.
- **보상 트랜잭션:** 단계가 실패할 경우, 이전 단계의 작업을 취소하는 보상 트랜잭션이 실행됩니다.

**장점:**

- 2PC보다 구현이 단순하며, 네트워크 지연이나 시스템 장애에 더 유연하게 대응할 수 있습니다.
- 성능이 우수하고, 시스템 확장성에 유리합니다.

**단점:**

- 각 단계에 대해 보상 트랜잭션을 설계해야 하므로 트랜잭션 설계가 복잡해질 수 있습니다.
- 즉각적인 일관성을 보장하지 않으므로, 일관성 문제를 적절히 처리해야 합니다.

## 분산 트랜잭션의 사용 사례

- **마이크로서비스 아키텍처:** 각 서비스가 독립적으로 운영되며, 여러 서비스에 걸쳐 분산 트랜잭션이 필요한 경우, 예를 들어 주문 처리 시스템에서 결제, 재고 관리, 배송 시스템 간의 일관성을 유지하기 위해 사용됩니다.

- **글로벌 금융 시스템:** 여러 지리적으로 분산된 데이터베이스에 걸쳐 트랜잭션을 처리해야 할 때, 예를 들어 국제 송금 시스템에서 각 국가의 데이터베이스 간 일관성을 유지하는 것이 필수적입니다.

- **대규모 분산 애플리케이션:** 여러 클라우드 서비스 또는 데이터 센터에 걸쳐 동작하는 애플리케이션에서 데이터 일관성을 유지하기 위해 분산 트랜잭션이 필요할 수 있습니다.

# 최종적 일관성 (Eventual Consistency)

최종적 일관성(Eventual Consistency)은 분산 시스템에서 중요한 일관성 모델 중 하나로, 여러 노드에 걸쳐 데이터를 복제하거나 분산할 때 사용됩니다. 이 모델에서는 즉각적인 데이터 일관성을 보장하지 않지만, 일정 시간이 지나면 시스템의 모든 노드가 일관된 상태에 도달하게 됩니다. 다음은 최종적 일관성에 대한 자세한 설명입니다.

## 기본 개념

최종적 일관성은 CAP 이론(Consistency, Availability, Partition tolerance)에서 주로 언급되는 개념입니다. CAP 이론에 따르면, 네트워크 파티션이 존재하는 상황에서 분산 시스템은 일관성, 가용성, 파티션 허용성 중 두 가지 특성만을 동시에 보장할 수 있습니다. 최종적 일관성은 이 세 가지 특성 중 가용성과 파티션 허용성을 우선시하면서 일관성은 일정 시간이 지나면 보장되는 모델입니다.

## 작동 방식

최종적 일관성은 다음과 같은 원리로 작동합니다:

1. **데이터 업데이트:** 사용자가 시스템에 데이터를 업데이트하면, 이 변경사항은 시스템의 모든 노드로 즉시 전파되지 않을 수 있습니다. 즉, 일부 노드는 최신 상태를 반영하지 않을 수 있습니다.
2. **배포 지연:** 데이터는 시스템의 모든 노드로 분산되는데 시간이 걸립니다. 이 과정에서 네트워크 지연이나 시스템 장애가 발생할 수 있으며, 특정 노드에 최신 데이터가 도달하기까지 시간이 걸릴 수 있습니다.
3. **일관성 달성:** 시간이 지나면서, 모든 노드는 이 데이터를 반영하게 되고, 시스템은 최종적으로 일관성 있는 상태에 도달합니다. 이 상태에서는 어느 노드에 접근하든지 동일한 데이터를 확인할 수 있습니다.

## 적용 사례

최종적 일관성은 여러 산업에서 다음과 같은 방식으로 활용됩니다:

- **NoSQL 데이터베이스:** Cassandra, DynamoDB, Riak 같은 분산형 NoSQL 데이터베이스 시스템은 최종적 일관성 모델을 채택하여 데이터를 전 세계에 걸쳐 분산 저장하고, 사용자에게 높은 가용성과 성능을 제공합니다.
- **CDN (Content Delivery Network):** CDN은 전 세계 여러 위치에 데이터를 복제하여 사용자에게 빠른 응답을 제공합니다. 새 콘텐츠가 업데이트되면 각 지역의 서버에 최종적으로 전파되지만, 전파되기 전까지는 이전 버전의 콘텐츠가 제공될 수 있습니다.
- **마이크로서비스 아키텍처:** 여러 서비스가 독립적으로 운영되고, 최종적으로 서로 일관된 상태를 유지하는 마이크로서비스 구조에서 최종적 일관성이 사용됩니다. 예를 들어, 주문 시스템에서 결제 처리와 재고 관리 시스템이 최종적으로 일관된 상태를 유지하게 됩니다.

## 장점

- **높은 가용성:** 네트워크 문제나 노드 장애가 발생하더라도 시스템은 계속해서 작동할 수 있습니다. 이로 인해 사용자는 언제나 서비스에 접근할 수 있습니다.
- **확장성:** 대규모 분산 시스템에서 수천 개의 노드를 사용하더라도 최종적 일관성 모델은 이러한 시스템을 효과적으로 관리할 수 있습니다.
- **유연성:** 시스템이 항상 최신 데이터를 제공할 필요가 없는 경우, 최종적 일관성 모델은 더욱 유연한 데이터 관리 방법을 제공합니다.

## 단점

- **데이터 불일치:** 특정 시점에서는 데이터가 일치하지 않을 수 있습니다. 이는 금융 거래나 실시간 데이터 분석 같은 즉각적인 정확성이 중요한 애플리케이션에는 부적합할 수 있습니다.
- **개발 복잡성:** 최종적 일관성을 고려하여 애플리케이션을 설계해야 하므로, 시스템을 이해하고 처리하는 데 추가적인 복잡성이 발생할 수 있습니다.

## 고려 사항

최종적 일관성을 채택할 때는 시스템의 요구 사항에 따라 일관성 모델을 선택해야 합니다. 예를 들어, 사용자가 최종적인 데이터 정확성을 허용할 수 있다면 최종적 일관성 모델이 적합할 수 있습니다. 반대로, 실시간으로 정확한 데이터가 필요하다면, 보다 강한 일관성 모델을 선택해야 할 것입니다.

이처럼 최종적 일관성은 대규모 분산 시스템에서 데이터의 일관성을 효율적으로 관리하기 위한 중요한 개념입니다. 분산 시스템의 요구사항과 특성에 따라 이 모델을 활용하는 것이 중요합니다.
